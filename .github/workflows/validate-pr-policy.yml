name: Validate PR Policy

on:
  pull_request:
    branches: [ main ]
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - labeled
      - unlabeled
      - edited
      - converted_to_draft

permissions:
  pull-requests: read
  contents: read
  checks: write

jobs:
  validate-pr-policy:
    name: Validate PR Policy
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout policy + code so we can read files from the repo
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2) OPA CLI for evaluation
      - name: Set up OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: latest

      # 3) Ensure tooling (jq + gh)
      - name: Ensure jq and gh
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          if ! command -v gh >/dev/null 2>&1; then
            type -p curl >/dev/null || sudo apt-get install curl -y
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update -y
            sudo apt-get install gh -y
          fi

      # 4) Build rich input.json purely from event/repo (no hardcoded env)
      - name: Build OPA input from PR event
        id: build-input
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # used by gh
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          EVENT_PATH="${GITHUB_EVENT_PATH}"
          REPO="${{ github.repository }}"
          PR_NUMBER="$(jq -r '.pull_request.number' "$EVENT_PATH")"

          echo "PR_NUMBER=$PR_NUMBER"

          # Helper: robust gh api call with retries. Returns non-zero on failure.
          gh_api() {
            set +e
            local url="$1"
            local accept="${2:-application/vnd.github+json}"
            local tries=3
            local delay=2
            local i=1
            local out
            while [ $i -le $tries ]; do
              out=$(gh api -H "Accept: $accept" "$url" 2>/dev/null)
              rc=$?
              if [ $rc -eq 0 ] && [ -n "$out" ]; then
                echo "$out"
                set -e
                return 0
              fi
              sleep $((delay * i))
              i=$((i+1))
            done
            set -e
            return 1
          }

          # Helper: call gh_api and return a safe default JSON when unavailable
          get_json_or_default() {
            local url="$1"; local default="$2"
            set +e
            out=$(gh_api "$url")
            rc=$?
            set -e
            if [ $rc -ne 0 ] || [ -z "$out" ]; then
              # Annotate the workflow logs so it's visible in the Actions UI
              echo "::warning::gh api $url failed after retries or returned empty; using default value"
              echo "$default"
            else
              echo "$out"
            fi
          }

          # --- Extract base/head refs, draft status, labels, mergeability, files changed, requested reviewers, etc.
          PR_JSON="$(get_json_or_default "/repos/${REPO}/pulls/${PR_NUMBER}" '{}')"
          BASE_REF="$(echo "$PR_JSON" | jq -r '.base.ref // ""')"
          HEAD_REF="$(echo "$PR_JSON" | jq -r '.head.ref // ""')"
          DRAFT="$(echo "$PR_JSON" | jq -r '.draft // false')"
          MERGEABLE_STATE="$(echo "$PR_JSON" | jq -r '.mergeable_state // "unknown"')"
          CHANGED_FILES="$(echo "$PR_JSON" | jq -r '.changed_files // 0')"
          TITLE="$(echo "$PR_JSON" | jq -r '.title // ""')"
          BODY="$(echo "$PR_JSON" | jq -r '.body // ""')"

          # Labels as array of strings (safe even if empty)
          LABELS_JSON="$(echo "$PR_JSON" | jq -c '[.labels[]?.name]')"
          # Requested reviewers (logins)
          REQ_REVIEWERS_JSON="$(echo "$PR_JSON" | jq -c '[.requested_reviewers[]?.login]')"

          # --- Approvers: array of distinct logins from review events with state APPROVED
          REVIEWS_JSON="$(get_json_or_default "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" '[]')"
          APPROVERS_JSON="$(echo "$REVIEWS_JSON" | jq -c 'map(select(.state == "APPROVED") | .user.login) | unique')"

          # --- Code owner approvers (subset)
          CODE_OWNER_APPROVERS_JSON="$(echo "$REVIEWS_JSON" | jq -c 'map(select(.state == "APPROVED" and .author_association == "OWNER") | .user.login) | unique')"

          # --- Repository defined environments (Settings → Environments)
          REPO_ENVS="$(get_json_or_default "/repos/${REPO}/environments" '{"environments":[]}')"
          REPO_ENVS="$(echo "$REPO_ENVS" | jq -c '.environments | map(.name)')"

          # --- Policy file from repo
          POLICY_PATH=".gate/github_pull_request_policy.json"
          if [ ! -f "$POLICY_PATH" ]; then
            echo "::error file=$POLICY_PATH::Policy file not found"
            exit 1
          fi
          POLICY_CONTENT="$(cat "$POLICY_PATH")"

          # --- Optional branch → env mapping file
          # Example:
          # {
          #   "by_base_branch": {
          #     "main": "prod",
          #     "develop": "staging",
          #     "feature/*": "dev"
          #   }
          # }
          MAP_PATH=".gate/env_mapping.json"
          MAP_CONTENT="{}"
          if [ -f "$MAP_PATH" ]; then
            MAP_CONTENT="$(cat "$MAP_PATH")"
          fi

          # --- Resolve environment (no hardcoding):
          # 1) A label like 'environment:prod' or 'env:staging'
          # 2) Mapping file by base branch (supports simple '*' suffix)
          # 3) If the policy defines exactly one environment, use it
          # 4) Otherwise, fail with a clear error (caller must specify)
          ENV_LABEL="$(echo "$LABELS_JSON" \
            | jq -r '.[]? | capture("^(?<k>env(ironment)?):(?<v>.+)$")? | select(.) | .v' \
            | head -n1 || true)"
          ENV_FROM_LABEL="${ENV_LABEL:-}"

          # Mapping by base branch:
          ENV_FROM_MAP=""
          if [ "$MAP_CONTENT" != "{}" ]; then
            # Exact match
            ENV_FROM_MAP="$(echo "$MAP_CONTENT" | jq -r --arg base "$BASE_REF" '.by_base_branch[$base] // empty')"
            # Wildcard (suffix '*'): find first pattern that matches prefix
            if [ -z "$ENV_FROM_MAP" ]; then
              ENV_FROM_MAP="$(echo "$MAP_CONTENT" | jq -r --arg base "$BASE_REF" '
                (.by_base_branch // {}) as $m
                | ($m | to_entries[]
                    | select(.key | endswith("*"))
                    | select($base | startswith((.key | sub("\\*$";""))))
                    | .value) // empty
              ' | head -n1)"
            fi
          fi

          # Read environments from policy
          POLICY_ENVS_JSON="$(echo "$POLICY_CONTENT" | jq -c '.policy.environments | keys')"
          POLICY_ENVS_COUNT="$(echo "$POLICY_ENVS_JSON" | jq -r 'length')"

          # Decide final ENV
          ENVIRONMENT=""
          if [ -n "${ENV_FROM_LABEL}" ]; then
            ENVIRONMENT="$ENV_FROM_LABEL"
          elif [ -n "${ENV_FROM_MAP}" ]; then
            ENVIRONMENT="$ENV_FROM_MAP"
          elif [ "$POLICY_ENVS_COUNT" = "1" ]; then
            ENVIRONMENT="$(echo "$POLICY_ENVS_JSON" | jq -r '.[0]')"
          else
            echo "::error::Unable to determine environment. Add a label like 'environment:prod', provide .gate/env_mapping.json, or make the policy have a single environment."
            echo "Detected policy environments: $POLICY_ENVS_JSON"
            echo "Labels: $LABELS_JSON"
            echo "Base branch: $BASE_REF"
            exit 1
          fi

          echo "ENVIRONMENT=$ENVIRONMENT"

          # --- DCO signed-off: true if all commits contain 'Signed-off-by:'
          COMMITS_JSON="$(get_json_or_default "/repos/${REPO}/pulls/${PR_NUMBER}/commits" '[]')"
          COMMITS_TOTAL="$(echo "$COMMITS_JSON" | jq 'length')"
          COMMITS_WITH_SIGNOFF="$(echo "$COMMITS_JSON" | jq '[ .[]?.commit.message | contains("Signed-off-by:") ] | map(select(.)) | length')"
          if [ "$COMMITS_TOTAL" -gt 0 ] && [ "$COMMITS_WITH_SIGNOFF" -eq "$COMMITS_TOTAL" ]; then
            SIGNED_OFF=true
          else
            SIGNED_OFF=false
          fi

          # --- Head commit / repo info
          HEAD_SHA="$(echo "$PR_JSON" | jq -r '.head.sha // ""')"
          HEAD_REPO_FULLNAME="$(echo "$PR_JSON" | jq -r '.head.repo.full_name // ""')"
          HEAD_REPO_FORK="$(echo "$PR_JSON" | jq -r '.head.repo.fork // false')"
          PR_AUTHOR_ASSOC="$(echo "$PR_JSON" | jq -r '.author_association // ""')"

          # --- Files changed list (array of filenames)
          FILES_JSON="$(get_json_or_default "/repos/${REPO}/pulls/${PR_NUMBER}/files" '[]')"
          FILES_JSON="$(echo "$FILES_JSON" | jq -c '[.[]?.filename]')"

          # --- Per-commit verification (GPG) info
          COMMIT_VERIFICATIONS_JSON="$(echo "$COMMITS_JSON" | jq -c 'map({sha: .sha, verified: (.commit.verification.verified // false), url: .html_url})')"

          # --- Combined commit status and check runs for head sha
          if [ -n "$HEAD_SHA" ]; then
            COMBINED_STATUS_JSON="$(get_json_or_default "/repos/${REPO}/commits/${HEAD_SHA}/status" '{"state":"unknown"}')"
            COMBINED_STATE="$(echo "$COMBINED_STATUS_JSON" | jq -r '.state // "unknown"')"
            CHECK_RUNS_JSON_RAW="$(get_json_or_default "/repos/${REPO}/commits/${HEAD_SHA}/check-runs" '{"check_runs":[]}')"
            CHECK_RUNS_JSON="$(echo "$CHECK_RUNS_JSON_RAW" | jq -c '.check_runs | map({name: .name, status: .status, conclusion: .conclusion})')"
          else
            # If head sha is missing we can't query statuses or checks — annotate so maintainers know
            echo "::warning::head SHA missing from PR JSON; skipping combined status and check_runs queries"
            COMBINED_STATUS_JSON='{"state":"unknown"}'
            COMBINED_STATE='unknown'
            CHECK_RUNS_JSON='[]'
          fi

          # --- Build input.json for OPA
          cat > input.json <<EOF
          {
            "environment": "$ENVIRONMENT",
            "ref": "refs/heads/${HEAD_REF}",
            "head_sha": "$HEAD_SHA",
            "head_repo_full_name": "$HEAD_REPO_FULLNAME",
            "head_repo_fork": $HEAD_REPO_FORK,
            "repo_environments": $REPO_ENVS,
            "repo_policy": $POLICY_CONTENT,
            "workflow_meta": {
              "action": "${{ github.event.action }}",
              "is_draft": $DRAFT,
              "mergeable_state": "$MERGEABLE_STATE",
              "requested_reviewers": $REQ_REVIEWERS_JSON,
              "labels": $LABELS_JSON,
              "title": $(jq -Rn --arg s "$TITLE" '$s'),
              "body": $(jq -Rn --arg s "$BODY" '$s'),
              "changed_files": $CHANGED_FILES,
              "base_ref": "$BASE_REF",
              "head_ref": "$HEAD_REF",
              "head_sha": "$HEAD_SHA",
              "approvers": $APPROVERS_JSON,
              "codeowner_approvers": $CODE_OWNER_APPROVERS_JSON,
              "signed_off": $SIGNED_OFF,
              "commit_verifications": $COMMIT_VERIFICATIONS_JSON,
              "combined_status": $COMBINED_STATUS_JSON,
              "combined_state": "$COMBINED_STATE",
              "check_runs": $CHECK_RUNS_JSON,
              "files_changed_list": $FILES_JSON,
              "pr_author_association": "$PR_AUTHOR_ASSOC",
              "pull_request": $PR_NUMBER
            }
          }
          EOF

          echo "Built input.json:"
          jq '.' input.json

      # 5) Evaluate with OPA and collect violations
      - name: Evaluate OPA policy
        id: eval
        run: |
          set -euo pipefail
          # Evaluate 'allow' explicitly from JSON output so shell status doesn't mislead
          ALLOW_VALUE="$(opa eval --format json --data .gate/github_pull_request.rego --input input.json 'data.github.pullrequest.allow' \
            | jq -r '.result[0].expressions[0].value')"
          echo "ALLOW=$ALLOW_VALUE" | tee -a "$GITHUB_OUTPUT"

          echo "Violations (if any):"
          opa eval --format pretty --data .gate/github_pull_request.rego --input input.json 'data.github.pullrequest.violations' || true

      # 6) Create a GitHub Check Run with the outcome
      - name: Report Check
        if: always()
        uses: actions/github-script@v7
        env:
          POL_ALLOW: ${{ steps.eval.outputs.ALLOW }}
        with:
          script: |
            const allowed = process.env.POL_ALLOW === 'true';
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Policy Validation',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: allowed ? 'success' : 'failure',
              output: {
                title: 'PR Policy Validation',
                summary: allowed
                  ? 'All PR policy checks passed.'
                  : 'PR policy validation failed.',
                text: allowed
                  ? '✓ Policy allowed the PR based on current repository state and event data.'
                  : '✗ Violations were detected. Open the workflow logs to see details.'
              }
            });
