name: Validate PR Policy

on:
  pull_request:
    branches: [ main ]
    types:
      [
        opened,
        synchronize,
        reopened,
        ready_for_review,
        labeled,
        unlabeled,
        edited,
        converted_to_draft
      ]

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  validate-pr-policy:
    name: Validate PR Policy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: latest

      - name: Ensure jq and gh
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y curl
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update -y && sudo apt-get install -y gh
          fi

      - name: Build OPA input from PR event
        id: build-input
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}       # used by gh
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          EVENT_PATH="$GITHUB_EVENT_PATH"
          REPO="${{ github.repository }}"
          PR_NUMBER="$(jq -r '.pull_request.number' "$EVENT_PATH")"

          echo "PR_NUMBER=$PR_NUMBER"

          # --- Small helpers with retry ---
          gh_api() {
            set +e
            local url="$1"
            local tries=3
            local delay=2
            local out rc i=1
            while [ $i -le $tries ]; do
              out=$(gh api -H "Accept: application/vnd.github+json" "$url" 2>/dev/null)
              rc=$?
              if [ $rc -eq 0 ] && [ -n "$out" ]; then
                echo "$out"
                set -e
                return 0
              fi
              sleep $((delay * i))
              i=$((i + 1))
            done
            set -e
            return 1
          }
          get_or() { gh_api "$1" || echo "$2"; }

          # --- PR data ---
          PR_JSON="$(get_or "/repos/${REPO}/pulls/${PR_NUMBER}" '{}')"
          BASE_REF="$(echo "$PR_JSON" | jq -r '.base.ref // ""')"     # target branch (e.g., main)
          HEAD_REF="$(echo "$PR_JSON" | jq -r '.head.ref // ""')"
          HEAD_SHA="$(echo "$PR_JSON" | jq -r '.head.sha // ""')"
          TITLE="$(echo "$PR_JSON" | jq -r '.title // ""')"
          BODY="$(echo "$PR_JSON" | jq -r '.body // ""')"
          DRAFT="$(echo "$PR_JSON" | jq -r '.draft // false')"
          LABELS_JSON="$(echo "$PR_JSON" | jq -c '[.labels[]?.name]')"

          # Approved reviewers -> approvers
          REVIEWS_JSON="$(get_or "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" '[]')"
          APPROVERS_JSON="$(echo "$REVIEWS_JSON" | jq -c 'map(select(.state=="APPROVED")|.user.login)|unique')"

          # Repo environments (sanity)
          REPO_ENVS_RAW="$(get_or "/repos/${REPO}/environments" '{"environments":[]}')"
          REPO_ENVS="$(echo "$REPO_ENVS_RAW" | jq -c '.environments | map(.name)')"

          # Commit signed-off detection (simple heuristic + label override)
          COMMITS_JSON="$(get_or "/repos/${REPO}/pulls/${PR_NUMBER}/commits" '[]')"
          SIGNED_OFF=$(
            echo "$COMMITS_JSON" |
            jq -r '[.[].commit.message | contains("Signed-off-by:")] | any' 2>/dev/null
          )
          if echo "$LABELS_JSON" | jq -e 'index("signed-off")' >/dev/null; then
            SIGNED_OFF=true
          fi
          [ "$SIGNED_OFF" != "true" ] && SIGNED_OFF=false

          # Load repo policy JSON
          POLICY_PATH=".gate/github_env_protect_policy.json"
          if [ ! -f "$POLICY_PATH" ]; then
            echo "::error file=$POLICY_PATH::Policy file not found"
            exit 1
          fi
          POLICY_CONTENT="$(cat "$POLICY_PATH")"
          POLICY_ENVS_JSON="$(echo "$POLICY_CONTENT" | jq -c '.policy.environments | keys')"

          # Resolve environment: label > policy.allowed_branches > single env in policy
          ENV_FROM_LABEL="$(
            echo "$LABELS_JSON" \
            | jq -r '
                [
                  .[]?                                  # iterate labels (if any)
                  | strings                             # ensure string
                  | (try (capture("(?i)^(env|environment):(?<v>.+)$").v) catch empty)
                ]
                | first // empty                        # first match or ""
            '
          )"
          ENV_FROM_POLICY=""
          while IFS= read -r env; do
            pats="$(echo "$POLICY_CONTENT" | jq -r --arg e "$env" '.policy.environments[$e].rules.allowed_branches // empty | @sh')"
            if [ -z "$pats" ]; then
              ENV_FROM_POLICY="$env"
              break
            fi
            eval "arr=($pats)"
            for p in "${arr[@]}"; do
              p="${p%\'}"
              p="${p#\'}"
              if [[ "$BASE_REF" == "$p" ]]; then
                ENV_FROM_POLICY="$env"
                break 2
              fi
            done
          done < <(echo "$POLICY_CONTENT" | jq -r '.policy.environments | keys[]')

          if [ -n "$ENV_FROM_LABEL" ]; then
            ENVIRONMENT="$ENV_FROM_LABEL"
          elif [ -n "$ENV_FROM_POLICY" ]; then
            ENVIRONMENT="$ENV_FROM_POLICY"
          elif [ "$(echo "$POLICY_ENVS_JSON" | jq 'length')" -eq 1 ]; then
            ENVIRONMENT="$(echo "$POLICY_ENVS_JSON" | jq -r '.[0]')"
          else
            echo "::error::Unable to determine environment. Add label 'environment:<env>' or ensure branch matches policy.allowed_branches."
            exit 1
          fi

          # Validate env presence
          echo "$POLICY_ENVS_JSON" | jq -e --arg env "$ENVIRONMENT" 'index($env) != null' >/dev/null 2>&1 || {
            echo "::error::Environment '$ENVIRONMENT' not listed in policy"
            exit 1
          }

          if [ "$(echo "$REPO_ENVS" | jq 'length')" -gt 0 ]; then
            echo "$REPO_ENVS" | jq -e --arg env "$ENVIRONMENT" 'index($env) != null' >/dev/null 2>&1 || {
              echo "::error::Environment '$ENVIRONMENT' is not configured in repository settings."
              exit 1
            }
          fi

          # Build workflow_meta for Rego (approvers/signed_off come from above)
          WF_META="$(jq -n \
            --argjson labels "$LABELS_JSON" \
            --argjson approvers "$APPROVERS_JSON" \
            --arg signed_str "$SIGNED_OFF" \
            --arg draft "$DRAFT" \
            '{
              ticket_refs: [],                  # not required by pullrequest policy
              approvers: $approvers,
              checks: { tests: null },          # not evaluated by this policy
              signed_off: ($signed_str=="true"),
              deployments_today: 0,
              labels: $labels,
              is_draft: ($draft=="true")
            }'
          )"

          # Build the Rego input expected by package github.pullrequest
          jq -n \
            --arg env "$ENVIRONMENT" \
            --arg ref "refs/heads/$BASE_REF" \
            --argjson repo_envs "$REPO_ENVS" \
            --argjson repo_policy "$POLICY_CONTENT" \
            --argjson wf_meta "$WF_META" \
            '{
              environment: $env,
              ref: $ref,
              repo_environments: $repo_envs,
              workflow_meta: $wf_meta,
              repo_policy: $repo_policy
            }' > input.json

          echo "Built input.json:"
          jq '.' input.json

      - name: Evaluate OPA policy
        id: eval
        run: |
          set -euo pipefail

          # Evaluate with fallbacks to avoid empty outputs
          if ! allow_json="$(opa eval --format json --data .gate --input input.json 'data.github.pullrequest.allow')"; then
            echo "::warning::opa eval for allow failed; defaulting to false"
            allow="false"
          else
            allow="$(echo "$allow_json" | jq -r '.result[0].expressions[0].value // false' 2>/dev/null || echo false)"
          fi
          echo "allow=$allow" >> "$GITHUB_OUTPUT"

          if ! violations_json="$(opa eval --format json --data .gate --input input.json 'data.github.pullrequest.violations')"; then
            echo "::warning::opa eval for violations failed; defaulting to []"
            vio="[]"
          else
            vio="$(echo "$violations_json" | jq -c '[.result[0].expressions[0].value[]?] // []' 2>/dev/null || echo '[]')"
          fi
          echo "violations=$vio" >> "$GITHUB_OUTPUT"

          # Render markdown; never empty
          env_val="$(jq -r '.environment // ""' input.json)"
          ref_val="$(jq -r '.ref // ""' input.json)"
          approvers_val="$(jq -c '.workflow_meta.approvers // []' input.json)"

          if [ "$allow" = "true" ]; then
            md=$'<!-- pr-policy-bot -->\n'
            md+=$'### ✅ PR Policy: **Compliant**\n'
            md+=$'- Environment: `'"$env_val"'`\n'
            md+=$'- Ref: `'"$ref_val"'`\n'
            md+=$'- Approvers: `'"$approvers_val"'`'
          else
            bullets="$(echo "$vio" | jq -r '.[] | "- " + (.msg // tostring)' 2>/dev/null || true)"
            if [ -z "${bullets:-}" ]; then
              bullets="- (No detailed violations returned)"
            fi
            md=$'<!-- pr-policy-bot -->\n'
            md+=$'### ❌ PR Policy: **Not compliant**\n'
            md+=$'**Violations**\n'
            md+="$bullets"
          fi

          # Emit multiline output for next step
          {
            echo 'comment_body<<EOF'
            printf '%s\n' "$md"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Create or update PR comment
        if: always()
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.eval.outputs.comment_body }}
        with:
          script: |
            const marker = '<!-- pr-policy-bot -->';
            const body = process.env.COMMENT_BODY || '### ⚠️ PR Policy: No result available (evaluation step failed)';
            const { owner, repo } = context.repo;
            const issue_number = context.payload.pull_request.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const existing = comments.find(c => (c.body || '').includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body
              });
            }

      - name: Create check run
        if: always()
        uses: actions/github-script@v7
        env:
          POL_ALLOW: ${{ steps.eval.outputs.allow }}
        with:
          script: |
            const allowed = process.env.POL_ALLOW === 'true';
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Policy Validation',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: allowed ? 'success' : 'failure',
              output: {
                title: 'PR Policy Validation',
                summary: allowed
                  ? 'All PR policy checks passed.'
                  : 'PR policy validation failed. See the PR comment for details.',
                text: 'Results were also posted as a PR comment.'
              }
            })
