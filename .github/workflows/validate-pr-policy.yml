name: Validate PR Policy

on:
  pull_request:
    branches: [ main ]
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - labeled
      - unlabeled
      - edited
      - converted_to_draft

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  validate-pr-policy:
    name: Validate PR Policy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: latest

      - name: Ensure jq and gh
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y curl
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update -y && sudo apt-get install -y gh
          fi

      - name: Build OPA input from PR event
        id: build-input
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          EVENT_PATH="$GITHUB_EVENT_PATH"
          REPO="${{ github.repository }}"
          PR_NUMBER="$(jq -r '.pull_request.number' "$EVENT_PATH")"

          echo "PR_NUMBER=$PR_NUMBER"

          gh_api() {
            set +e
            local url="$1"
            local tries=3
            local delay=2
            local out rc i=1
            while [ $i -le $tries ]; do
              out=$(gh api -H "Accept: application/vnd.github+json" "$url" 2>/dev/null)
              rc=$?
              if [ $rc -eq 0 ] && [ -n "$out" ]; then
                echo "$out"
                set -e
                return 0
              fi
              sleep $((delay * i))
              i=$((i + 1))
            done
            set -e
            return 1
          }
          get_or() { gh_api "$1" || echo "$2"; }

          PR_JSON="$(get_or "/repos/${REPO}/pulls/${PR_NUMBER}" '{}')"
          BASE_REF="$(echo "$PR_JSON" | jq -r '.base.ref // ""')"
          HEAD_REF="$(echo "$PR_JSON" | jq -r '.head.ref // ""')"
          HEAD_SHA="$(echo "$PR_JSON" | jq -r '.head.sha // ""')"
          TITLE="$(echo "$PR_JSON" | jq -r '.title // ""')"
          BODY="$(echo "$PR_JSON" | jq -r '.body // ""')"
          DRAFT="$(echo "$PR_JSON" | jq -r '.draft // false')"
          LABELS_JSON="$(echo "$PR_JSON" | jq -c '[.labels[]?.name]')"

          REVIEWS_JSON="$(get_or "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" '[]')"
          APPROVERS_JSON="$(echo "$REVIEWS_JSON" | jq -c 'map(select(.state=="APPROVED")|.user.login)|unique')"

          REPO_ENVS_RAW="$(get_or "/repos/${REPO}/environments" '{"environments":[]}')"
          REPO_ENVS="$(echo "$REPO_ENVS_RAW" | jq -c '.environments | map(.name)')"

          COMMITS_JSON="$(get_or "/repos/${REPO}/pulls/${PR_NUMBER}/commits" '[]')"
          SIGNED_OFF=$(
            echo "$COMMITS_JSON" |
            jq -r '[.[].commit.message | contains("Signed-off-by:")] | any' 2>/dev/null
          )
          if echo "$LABELS_JSON" | jq -e 'index("signed-off")' >/dev/null; then
            SIGNED_OFF=true
          fi
          [ "$SIGNED_OFF" != "true" ] && SIGNED_OFF=false

          if [ -n "$HEAD_SHA" ]; then
            COMBINED_STATUS_JSON="$(get_or "/repos/${REPO}/commits/${HEAD_SHA}/status" '{"state":"unknown"}')"
            COMBINED_STATE="$(echo "$COMBINED_STATUS_JSON" | jq -r '.state // "unknown"')"
          else
            COMBINED_STATE="unknown"
          fi
          TESTS_BOOL=false
          if [ "$COMBINED_STATE" = "success" ]; then
            TESTS_BOOL=true
          fi

          POLICY_PATH=".gate/github_env_protect_policy.json"
          if [ ! -f "$POLICY_PATH" ]; then
            echo "::error file=$POLICY_PATH::Policy file not found"
            exit 1
          fi
          POLICY_CONTENT="$(cat "$POLICY_PATH")"
          POLICY_ENVS_JSON="$(echo "$POLICY_CONTENT" | jq -c '.policy.environments | keys')"

          ENV_FROM_LABEL="$(echo "$LABELS_JSON" | jq -r 'map(select(test("^(env|environment):"; "i"))) | .[0] // empty | sub("^(env|environment):"; ""; "i")')"
          ENV_FROM_POLICY=""
          while IFS= read -r env; do
            pats="$(echo "$POLICY_CONTENT" | jq -r --arg e "$env" '.policy.environments[$e].rules.allowed_branches // empty | @sh')"
            if [ -z "$pats" ]; then
              ENV_FROM_POLICY="$env"
              break
            fi
            eval "arr=($pats)"
            for p in "${arr[@]}"; do
              p="${p%\'}"
              p="${p#\'}"
              if [[ "$BASE_REF" == "$p" ]]; then
                ENV_FROM_POLICY="$env"
                break 2
              fi
            done
          done < <(echo "$POLICY_CONTENT" | jq -r '.policy.environments | keys[]')

          if [ -n "$ENV_FROM_LABEL" ]; then
            ENVIRONMENT="$ENV_FROM_LABEL"
          elif [ -n "$ENV_FROM_POLICY" ]; then
            ENVIRONMENT="$ENV_FROM_POLICY"
          elif [ "$(echo "$POLICY_ENVS_JSON" | jq 'length')" -eq 1 ]; then
            ENVIRONMENT="$(echo "$POLICY_ENVS_JSON" | jq -r '.[0]')"
          else
            echo "::error::Unable to determine environment. Add label 'environment:<env>' or ensure branch matches policy.allowed_branches."
            exit 1
          fi

          echo "$POLICY_ENVS_JSON" | jq -e --arg env "$ENVIRONMENT" 'index($env) != null' >/dev/null 2>&1 || {
            echo "::error::Environment '$ENVIRONMENT' not listed in policy"
            exit 1
          }

          if [ "$(echo "$REPO_ENVS" | jq 'length')" -gt 0 ]; then
            echo "$REPO_ENVS" | jq -e --arg env "$ENVIRONMENT" 'index($env) != null' >/dev/null 2>&1 || {
              echo "::error::Environment '$ENVIRONMENT' is not configured in repository settings."
              exit 1
            }
          fi

          TICKET_PATTERN="$(echo "$POLICY_CONTENT" | jq -r --arg e "$ENVIRONMENT" '.policy.environments[$e].rules.ticket_pattern // ""')"
          if [ -n "$TICKET_PATTERN" ] && [ "$TICKET_PATTERN" != "null" ]; then
            TICKETS="$(jq -Rnc --arg t "$TITLE" --arg b "$BODY" --arg p "$TICKET_PATTERN" '
              def finds($s;$re): [ $s | scan($re) ];
              ( finds($t;$p) + finds($b;$p) ) | unique'
            )"
          else
            TICKETS="[]"
          fi

          WF_META="$(jq -n \
            --argjson labels "$LABELS_JSON" \
            --argjson approvers "$APPROVERS_JSON" \
            --argjson tickets "$TICKETS" \
            --arg tests_str "$TESTS_BOOL" \
            --arg signed_str "$SIGNED_OFF" \
            --arg draft "$DRAFT" \
            '{
              ticket_refs: $tickets,
              approvers: $approvers,
              checks: { tests: ($tests_str=="true") },
              signed_off: ($signed_str=="true"),
              deployments_today: 0,
              labels: $labels,
              is_draft: ($draft=="true")
            }'
          )"

          jq -n \
            --arg env "$ENVIRONMENT" \
            --arg ref "refs/heads/$BASE_REF" \
            --argjson repo_envs "$REPO_ENVS" \
            --argjson repo_policy "$POLICY_CONTENT" \
            --argjson wf_meta "$WF_META" \
            '{
              environment: $env,
              ref: $ref,
              repo_environments: $repo_envs,
              workflow_meta: $wf_meta,
              repo_policy: $repo_policy
            }' > input.json

          echo "Built input.json:"
          jq '.' input.json

      - name: Evaluate OPA policy
        id: eval
        run: |
          set -euo pipefail

          allow_json="$(opa eval --format json --data .gate --input input.json 'data.github.pullrequest.allow')"
          violations_json="$(opa eval --format json --data .gate --input input.json 'data.github.pullrequest.violations')"

          allow="$(echo "$allow_json" | jq -r '.result[0].expressions[0].value // false')"
          echo "allow=$allow" >> "$GITHUB_OUTPUT"

          vio="$(echo "$violations_json" | jq -c '[.result[0].expressions[0].value[]?] // []')"
          echo "violations=$vio" >> "$GITHUB_OUTPUT"

          if [ "$allow" = "true" ]; then
            env_val="$(jq -r '.environment' input.json)"
            ref_val="$(jq -r '.ref' input.json)"
            approvers_val="$(jq -c '.workflow_meta.approvers' input.json)"
            md="### ✅ PR Policy: **Compliant**\n"
            md+="- Environment: \`$env_val\`\n"
            md+="- Ref: \`$ref_val\`\n"
            md+="- Approvers: \`$approvers_val\`\n"
          else
            bullets="$(echo "$vio" | jq -r '.[] | "- " + (.msg // tostring)')"
            [ -z "$bullets" ] && bullets="- (No detailed violations returned)"
            md="### ❌ PR Policy: **Not compliant**\n**Violations**\n$bullets\n"
          fi

          # expose the comment body as a multiline output for subsequent steps
          echo "comment_body<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n' "$md" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create or update PR comment
        if: always()
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.eval.outputs.comment_body }}
        with:
          script: |
            const marker = '<!-- pr-policy-bot -->';
            const body = process.env.COMMENT_BODY || '';
            const { owner, repo } = context.repo;
            const issue_number = context.payload.pull_request.number;

            const list = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const existing = list.data.find(c => (c.body || '').includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body
              });
            }

      - name: Create check run
        if: always()
        uses: actions/github-script@v7
        env:
          POL_ALLOW: ${{ steps.eval.outputs.allow }}
        with:
          script: |
            const allowed = process.env.POL_ALLOW === 'true';
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Policy Validation',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: allowed ? 'success' : 'failure',
              output: {
                title: 'PR Policy Validation',
                summary: allowed
                  ? 'All PR policy checks passed.'
                  : 'PR policy validation failed. See the PR comment for details.',
                text: 'Results were also posted as a PR comment.'
              }
            })
